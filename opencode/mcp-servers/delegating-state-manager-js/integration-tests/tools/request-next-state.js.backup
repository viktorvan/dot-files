/**
 * State transition tests using request_next_state tool
 */

import { MCPTestClient, createNewSession, completeWorkflowToDelegation } from '../helpers.js';

describe('State Transition Tests', () => {
  let client;
  let sessionId = null;
  let reviewId = null;

  beforeEach(async () => {
    client = new MCPTestClient();
    await client.startServer();
  });

  afterEach(async () => {
    if (client) {
      await client.shutdown();
    }
  });

  test('Error: Missing session_id parameter', async () => {
    await expect(client.callTool('request_next_state', {})).rejects.toThrow(/session_id is required/);
  });

  test('Error: Null session_id parameter', async () => {
    await expect(client.callTool('request_next_state', { session_id: null })).rejects.toThrow(/session_id is required/);
  });

  test('ANALYSIS → PLAN Transition', async () => {
    // First create a session using the new tool
    const currentSessionId = await createNewSession(client);

    const result = await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        clarifying_questions_text: 'What is the main objective of this task?',
        clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
      },
      notes: 'Moving from analysis to planning phase'
    });
    const response = JSON.parse(result.content[0].text);

    expect(response.approved).toBe(true);
    expect(response.state).toBe('PLAN');
  });

  test('PLAN → REVIEW_PLAN Transition', async () => {
    // Create new session and go through ANALYSIS → PLAN first
    const currentSessionId = await createNewSession(client);

    await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        clarifying_questions_text: 'What is the main objective of this task?',
        clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
      }
    });

    const result = await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
      },
      notes: 'Plan created, ready for review'
    });
    const response = JSON.parse(result.content[0].text);

    expect(response.approved).toBe(true);
    expect(response.state).toBe('REVIEW_PLAN');
  });

  test('Complete workflow: REVIEW_PLAN → USER_APPROVAL → DELEGATION → REVIEW_IMPLEMENTATION → DONE', async () => {
    // Create session and go through initial states
    const currentSessionId = await createNewSession(client);

    // ANALYSIS → PLAN
    await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        clarifying_questions_text: 'What is the main objective of this task?',
        clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
      }
    });

    // PLAN → REVIEW_PLAN
    await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
      }
    });

    // Submit plan review to get review_id
    const reviewResult = await client.callTool('submit_review', {
      session_id: currentSessionId,
      review_type: 'PLAN',
      verdict: 'APPROVED'
    });
    const reviewId = JSON.parse(reviewResult.content[0].text).review_id;

    // REVIEW_PLAN → USER_APPROVAL
    const userApprovalResult = await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: { review_id: reviewId }
    });
    const userApprovalResponse = JSON.parse(userApprovalResult.content[0].text);
    expect(userApprovalResponse.approved).toBe(true);
    expect(userApprovalResponse.state).toBe('USER_APPROVAL');

    // USER_APPROVAL → DELEGATION
    const delegationResult = await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        user_approval_text: 'Yes I approve this plan. Please proceed with implementation.'
      }
    });
    const delegationResponse = JSON.parse(delegationResult.content[0].text);
    expect(delegationResponse.approved).toBe(true);
    expect(delegationResponse.state).toBe('DELEGATION');

    // Create and complete task
    const taskResult = await client.callTool('start_task', {
      session_id: currentSessionId,
      task_id: 'state-transition-test-task'
    });
    const taskId = JSON.parse(taskResult.content[0].text).task_id;

    await client.callTool('finish_task', {
      session_id: currentSessionId,
      task_id: taskId,
      status: 'COMPLETED'
    });

    // DELEGATION → REVIEW_IMPLEMENTATION
    const reviewImplResult = await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: { task_ids: [taskId] }
    });
    const reviewImplResponse = JSON.parse(reviewImplResult.content[0].text);
    expect(reviewImplResponse.approved).toBe(true);
    expect(reviewImplResponse.state).toBe('REVIEW_IMPLEMENTATION');

    // Submit implementation review
    const implReviewResult = await client.callTool('submit_review', {
      session_id: currentSessionId,
      review_type: 'IMPLEMENTATION',
      verdict: 'APPROVED'
    });
    const implReviewId = JSON.parse(implReviewResult.content[0].text).review_id;

    // REVIEW_IMPLEMENTATION → DONE
    const doneResult = await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: { review_id: implReviewId }
    });
    const doneResponse = JSON.parse(doneResult.content[0].text);
    expect(doneResponse.approved).toBe(true);
    expect(doneResponse.state).toBe('DONE');
  });

  describe('DELEGATION task validation', () => {
    test('cancelled tasks are filtered out and do not cause validation to fail', async () => {
      // Create a new session for this test
      const newSessionId = await createNewSession(client);
      await completeWorkflowToDelegation(client, newSessionId);

      // Start some tasks
      const completedTaskResult = await client.callTool('start_task', {
        session_id: newSessionId,
        task_id: 'completed-task-1'
      });
      const completedTaskId = JSON.parse(completedTaskResult.content[0].text).task_id;

      const cancelledTaskResult = await client.callTool('start_task', {
        session_id: newSessionId,
        task_id: 'cancelled-task-1'
      });
      const cancelledTaskId = JSON.parse(cancelledTaskResult.content[0].text).task_id;

      // Finish tasks with different statuses
      await client.callTool('finish_task', {
        session_id: newSessionId,
        task_id: completedTaskId,
        status: 'COMPLETED'
      });

      await client.callTool('finish_task', {
        session_id: newSessionId,
        task_id: cancelledTaskId,
        status: 'CANCELLED'
      });

      // DELEGATION transition - should succeed by only including completed tasks
      const delegationResult = await client.callTool('request_next_state', {
        session_id: newSessionId,
        evidence: {
          task_ids: [completedTaskId] // Only including completed task, omitting cancelled task
        },
        notes: 'Testing cancelled task filtering - should succeed'
      });
      const delegationResponse = JSON.parse(delegationResult.content[0].text);

      expect(delegationResponse.approved).toBe(true);
      expect(delegationResponse.state).toBe('REVIEW_IMPLEMENTATION');
    });

    test('validation fails if at least one task passed has status aborted', async () => {
      // Create a new session for this test
      const newSessionId = await createNewSession(client);
      await completeWorkflowToDelegation(client, newSessionId);

      // Start tasks
      const completedTaskResult = await client.callTool('start_task', {
        session_id: newSessionId,
        task_id: 'completed-task-2'
      });
      const completedTaskId = JSON.parse(completedTaskResult.content[0].text).task_id;

      const abortedTaskResult = await client.callTool('start_task', {
        session_id: newSessionId,
        task_id: 'aborted-task-1'
      });
      const abortedTaskId = JSON.parse(abortedTaskResult.content[0].text).task_id;

      // Finish tasks
      await client.callTool('finish_task', {
        session_id: newSessionId,
        task_id: completedTaskId,
        status: 'COMPLETED'
      });

      await client.callTool('finish_task', {
        session_id: newSessionId,
        task_id: abortedTaskId,
        status: 'ABORTED'
      });

      // DELEGATION transition - should fail because aborted task is included
      await expect(client.callTool('request_next_state', {
        session_id: newSessionId,
        evidence: {
          task_ids: [completedTaskId, abortedTaskId] // Including aborted task should fail
        },
        notes: 'Testing aborted task validation - should fail'
      })).rejects.toThrow(/aborted|status/);
    });

    test('validation fails if completed task exists but not included in evidence', async () => {
      // Create a new session for this test
      const newSessionId = await createNewSession(client);
      await completeWorkflowToDelegation(client, newSessionId);

      // Start multiple tasks
      const task1Result = await client.callTool('start_task', {
        session_id: newSessionId,
        task_id: 'orphaned-completed-task'
      });
      const task1Id = JSON.parse(task1Result.content[0].text).task_id;

      const task2Result = await client.callTool('start_task', {
        session_id: newSessionId,
        task_id: 'cancelled-task'
      });
      const task2Id = JSON.parse(task2Result.content[0].text).task_id;

      const task3Result = await client.callTool('start_task', {
        session_id: newSessionId,
        task_id: 'included-task'
      });
      const task3Id = JSON.parse(task3Result.content[0].text).task_id;

      // Finish tasks
      await client.callTool('finish_task', {
        session_id: newSessionId,
        task_id: task1Id,
        status: 'COMPLETED'
      });

      await client.callTool('finish_task', {
        session_id: newSessionId,
        task_id: task2Id,
        status: 'CANCELLED'
      });

      await client.callTool('finish_task', {
        session_id: newSessionId,
        task_id: task3Id,
        status: 'COMPLETED'
      });

      // DELEGATION transition - should fail because not all completed tasks are included
      await expect(client.callTool('request_next_state', {
        session_id: newSessionId,
        evidence: {
          task_ids: [task3Id] // Only including one completed task, leaving orphaned completed task
        },
        notes: 'Testing orphaned task validation - should fail'
      })).rejects.toThrow(/not included|evidence|completed/);
    });

    test('validation fails if task_id in evidence does not exist in session', async () => {
      // Create a new session for this test
      const newSessionId = await createNewSession(client);
      await completeWorkflowToDelegation(client, newSessionId);

      // DELEGATION transition with nonexistent task_id - should fail
      await expect(client.callTool('request_next_state', {
        session_id: newSessionId,
        evidence: {
          task_ids: ['nonexistent-task-id-12345'] // Task that doesn't exist in session
        },
        notes: 'Testing nonexistent task validation - should fail'
      })).rejects.toThrow(/does not exist|not found/);
    });

    test('validation fails if task in evidence has status started (not finished)', async () => {
      // Create a new session for this test
      const newSessionId = await createNewSession(client);
      await completeWorkflowToDelegation(client, newSessionId);

      // Start a task but don't finish it
      const startedTaskResult = await client.callTool('start_task', {
        session_id: newSessionId,
        task_id: 'started-unfinished-task'
      });
      const startedTaskId = JSON.parse(startedTaskResult.content[0].text).task_id;

      // DELEGATION transition with unfinished task - should fail
      await expect(client.callTool('request_next_state', {
        session_id: newSessionId,
        evidence: {
          task_ids: [startedTaskId] // Task is started but not finished
        },
        notes: 'Testing started task validation - should fail'
      })).rejects.toThrow(/started|not finished|status/);
    });

    test('validation fails if task_ids array is empty', async () => {
      // Create a new session for this test
      const newSessionId = await createNewSession(client);
      await completeWorkflowToDelegation(client, newSessionId);

      // DELEGATION transition with empty task_ids array - should fail
      await expect(client.callTool('request_next_state', {
        session_id: newSessionId,
        evidence: {
          task_ids: [] // Empty array should fail validation
        },
        notes: 'Testing empty task_ids validation - should fail'
      })).rejects.toThrow(/at least.*task.*required|must contain at least/i);
    });
  });

  describe('USER_APPROVAL evidence validation', () => {
    test('user_approval_text with "yes i approve" (lowercase) should pass', async () => {
      // Create session and get to USER_APPROVAL state
      const currentSessionId = await createNewSession(client);

      // ANALYSIS → PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          clarifying_questions_text: 'What is the main objective of this task?',
          clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
        }
      });

      // PLAN → REVIEW_PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
        }
      });

      // Submit plan review to get review_id
      const reviewResult = await client.callTool('submit_review', {
        session_id: currentSessionId,
        review_type: 'PLAN',
        verdict: 'APPROVED'
      });
      const reviewId = JSON.parse(reviewResult.content[0].text).review_id;

      // REVIEW_PLAN → USER_APPROVAL
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: { review_id: reviewId }
      });

      // USER_APPROVAL → DELEGATION with "yes i approve" in lowercase
      const delegationResult = await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          user_approval_text: 'yes i approve this plan.'
        }
      });
      const delegationResponse = JSON.parse(delegationResult.content[0].text);
      expect(delegationResponse.approved).toBe(true);
      expect(delegationResponse.state).toBe('DELEGATION');
    });

    test('user_approval_text with "YES I APPROVE" (uppercase) should pass', async () => {
      // Create session and get to USER_APPROVAL state
      const currentSessionId = await createNewSession(client);

      // ANALYSIS → PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          clarifying_questions_text: 'What is the main objective of this task?',
          clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
        }
      });

      // PLAN → REVIEW_PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
        }
      });

      // Submit plan review to get review_id
      const reviewResult = await client.callTool('submit_review', {
        session_id: currentSessionId,
        review_type: 'PLAN',
        verdict: 'APPROVED'
      });
      const reviewId = JSON.parse(reviewResult.content[0].text).review_id;

      // REVIEW_PLAN → USER_APPROVAL
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: { review_id: reviewId }
      });

      // USER_APPROVAL → DELEGATION with "YES I APPROVE" in uppercase
      const delegationResult = await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          user_approval_text: 'YES I APPROVE this plan completely!'
        }
      });
      const delegationResponse = JSON.parse(delegationResult.content[0].text);
      expect(delegationResponse.approved).toBe(true);
      expect(delegationResponse.state).toBe('DELEGATION');
    });

    test('user_approval_text with "Yes I Approve" (mixed case) should pass', async () => {
      // Create session and get to USER_APPROVAL state
      const currentSessionId = await createNewSession(client);

      // ANALYSIS → PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          clarifying_questions_text: 'What is the main objective of this task?',
          clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
        }
      });

      // PLAN → REVIEW_PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
        }
      });

      // Submit plan review to get review_id
      const reviewResult = await client.callTool('submit_review', {
        session_id: currentSessionId,
        review_type: 'PLAN',
        verdict: 'APPROVED'
      });
      const reviewId = JSON.parse(reviewResult.content[0].text).review_id;

      // REVIEW_PLAN → USER_APPROVAL
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: { review_id: reviewId }
      });

      // USER_APPROVAL → DELEGATION with "Yes I Approve" in mixed case
      const delegationResult = await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          user_approval_text: 'Yes I Approve this plan. Please proceed with implementation.'
        }
      });
      const delegationResponse = JSON.parse(delegationResult.content[0].text);
      expect(delegationResponse.approved).toBe(true);
      expect(delegationResponse.state).toBe('DELEGATION');
    });

    test('user_approval_text without "yes i approve" should fail', async () => {
      // Create session and get to USER_APPROVAL state
      const currentSessionId = await createNewSession(client);

      // ANALYSIS → PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          clarifying_questions_text: 'What is the main objective of this task?',
          clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
        }
      });

      // PLAN → REVIEW_PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
        }
      });

      // Submit plan review to get review_id
      const reviewResult = await client.callTool('submit_review', {
        session_id: currentSessionId,
        review_type: 'PLAN',
        verdict: 'APPROVED'
      });
      const reviewId = JSON.parse(reviewResult.content[0].text).review_id;

      // REVIEW_PLAN → USER_APPROVAL
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: { review_id: reviewId }
      });

      // USER_APPROVAL → DELEGATION without "yes i approve" - should fail
      await expect(client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          user_approval_text: 'I approve this plan completely.'
        }
      })).rejects.toThrow(/user approval is missing/i);
    });

    test('user_approval_text with empty string should fail', async () => {
      // Create session and get to USER_APPROVAL state
      const currentSessionId = await createNewSession(client);

      // ANALYSIS → PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          clarifying_questions_text: 'What is the main objective of this task?',
          clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
        }
      });

      // PLAN → REVIEW_PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
        }
      });

      // Submit plan review to get review_id
      const reviewResult = await client.callTool('submit_review', {
        session_id: currentSessionId,
        review_type: 'PLAN',
        verdict: 'APPROVED'
      });
      const reviewId = JSON.parse(reviewResult.content[0].text).review_id;

      // REVIEW_PLAN → USER_APPROVAL
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: { review_id: reviewId }
      });

      // USER_APPROVAL → DELEGATION with empty string - should fail
      await expect(client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          user_approval_text: ''
        }
      })).rejects.toThrow(/user approval is missing/i);
    });

    test('user_approval_text with only "no" should fail', async () => {
      // Create session and get to USER_APPROVAL state
      const currentSessionId = await createNewSession(client);

      // ANALYSIS → PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          clarifying_questions_text: 'What is the main objective of this task?',
          clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
        }
      });

      // PLAN → REVIEW_PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
        }
      });

      // Submit plan review to get review_id
      const reviewResult = await client.callTool('submit_review', {
        session_id: currentSessionId,
        review_type: 'PLAN',
        verdict: 'APPROVED'
      });
      const reviewId = JSON.parse(reviewResult.content[0].text).review_id;

      // REVIEW_PLAN → USER_APPROVAL
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: { review_id: reviewId }
      });

      // USER_APPROVAL → DELEGATION with "no" instead of "yes i approve" - should fail
      await expect(client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          user_approval_text: 'No, I do not approve this plan.'
        }
      })).rejects.toThrow(/user approval is missing/i);
    });

    test('user_approval_text with only "yes" (without "approve") should fail', async () => {
      // Create session and get to USER_APPROVAL state
      const currentSessionId = await createNewSession(client);

      // ANALYSIS → PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          clarifying_questions_text: 'What is the main objective of this task?',
          clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
        }
      });

      // PLAN → REVIEW_PLAN
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          plan_summary: 'Detailed plan: Create stdio-based integration tests with comprehensive workflow coverage including all 4 tools and state transitions.'
        }
      });

      // Submit plan review to get review_id
      const reviewResult = await client.callTool('submit_review', {
        session_id: currentSessionId,
        review_type: 'PLAN',
        verdict: 'APPROVED'
      });
      const reviewId = JSON.parse(reviewResult.content[0].text).review_id;

      // REVIEW_PLAN → USER_APPROVAL
      await client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: { review_id: reviewId }
      });

      // USER_APPROVAL → DELEGATION with only "yes" (missing "approve") - should fail
      await expect(client.callTool('request_next_state', {
        session_id: currentSessionId,
        evidence: {
          user_approval_text: 'Yes, this plan looks good to me.'
        }
      })).rejects.toThrow(/user approval is missing/i);
    });
  });

  test('Error: Terminal State Transition', async () => {
    // Create a session and complete entire workflow to DONE state
    const currentSessionId = await createNewSession(client);
    await completeWorkflowToDelegation(client, currentSessionId);

    // Complete a task to reach REVIEW_IMPLEMENTATION
    const taskResult = await client.callTool('start_task', {
      session_id: currentSessionId,
      task_id: 'terminal-test-task'
    });
    const taskId = JSON.parse(taskResult.content[0].text).task_id;

    await client.callTool('finish_task', {
      session_id: currentSessionId,
      task_id: taskId,
      status: 'COMPLETED'
    });

    await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: { task_ids: [taskId] }
    });

    // Submit implementation review and go to DONE
    const implReviewResult = await client.callTool('submit_review', {
      session_id: currentSessionId,
      review_type: 'IMPLEMENTATION',
      verdict: 'APPROVED'
    });
    const implReviewId = JSON.parse(implReviewResult.content[0].text).review_id;

    await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: { review_id: implReviewId }
    });

    // Now try to transition from DONE (terminal state) - should fail
    await expect(client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {}
    })).rejects.toThrow(/Cannot transition from state|already at final state/);
  });
});

describe('Audit Logging Tests', () => {
  let client;
  let sessionManager;

  beforeEach(async () => {
    client = new MCPTestClient();
    await client.startServer();

    // Initialize session manager with same path as server
    const { SessionManager } = await import('../../lib/session.js');
    sessionManager = new SessionManager('./sessions');
  });

  afterEach(async () => {
    if (client) {
      await client.shutdown();
    }
    // Clear session cache to force reload from disk
    if (sessionManager) {
      sessionManager.clearCache();
    }
  });

  test('Transition failures are logged to session state', async () => {
    const currentSessionId = await createNewSession(client);

    // Try transition with missing evidence - should log failure
    await expect(client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {} // Missing required evidence
    })).rejects.toThrow(/Missing required fields/);

    // Add a small delay to ensure file operations complete
    await new Promise(resolve => setTimeout(resolve, 200));

    // Clear cache and reload session to get latest state from disk
    sessionManager.clearCache();
    const sessionData = await sessionManager.loadSession(currentSessionId);

    expect(sessionData.transition_failures).toBeDefined();
    expect(sessionData.transition_failures.length).toBeGreaterThan(0);

    // Find the missing evidence failure in the logs
    const missingEvidenceFailure = sessionData.transition_failures.find(f => f.type === 'missing_evidence');
    expect(missingEvidenceFailure).toBeDefined();
    expect(missingEvidenceFailure.details).toContain('Missing required fields');
    expect(missingEvidenceFailure.attempted_transition).toBe('ANALYSIS -> PLAN');
    expect(missingEvidenceFailure.timestamp).toBeDefined();
  });

  test('Evidence validation errors are properly categorized in logs', async () => {
    const currentSessionId = await createNewSession(client);

    // Test invalid format error
    await expect(client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        clarifying_questions_text: 'x', // Too short
        clarifying_answers_text: 'Valid answer that is long enough'
      }
    })).rejects.toThrow(/must be at least/);

    // Add a small delay to ensure file operations complete
    await new Promise(resolve => setTimeout(resolve, 200));

    // Clear cache and reload session to get latest state from disk
    sessionManager.clearCache();
    const sessionData = await sessionManager.loadSession(currentSessionId);

    // Find the invalid_format failure in the logs
    const invalidFormatFailure = sessionData.transition_failures.find(f => f.type === 'invalid_format');
    expect(invalidFormatFailure).toBeDefined();
    expect(invalidFormatFailure.details).toContain('must be at least');
  });

  test('Terminal state transition attempts are logged', async () => {
    // Create a session and complete entire workflow to DONE state
    const currentSessionId = await createNewSession(client);
    await completeWorkflowToDelegation(client, currentSessionId);

    // Complete a task to reach REVIEW_IMPLEMENTATION
    const taskResult = await client.callTool('start_task', {
      session_id: currentSessionId,
      task_id: 'logging-terminal-test-task'
    });
    const taskId = JSON.parse(taskResult.content[0].text).task_id;

    await client.callTool('finish_task', {
      session_id: currentSessionId,
      task_id: taskId,
      status: 'COMPLETED'
    });

    await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: { task_ids: [taskId] }
    });

    // Submit implementation review and go to DONE
    const implReviewResult = await client.callTool('submit_review', {
      session_id: currentSessionId,
      review_type: 'IMPLEMENTATION',
      verdict: 'APPROVED'
    });
    const implReviewId = JSON.parse(implReviewResult.content[0].text).review_id;

    await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: { review_id: implReviewId }
    });

    // Try to transition from DONE (terminal state) - should fail and be logged
    await expect(client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {}
    })).rejects.toThrow(/Cannot transition from state|already at final state/);

    // Add a small delay to ensure file operations complete
    await new Promise(resolve => setTimeout(resolve, 200));

    // Clear cache and reload session to get latest state from disk
    sessionManager.clearCache();
    const sessionData = await sessionManager.loadSession(currentSessionId);

    const terminalFailure = sessionData.transition_failures.find(f => f.type === 'terminal_state');
    expect(terminalFailure).toBeDefined();
    expect(terminalFailure.details).toContain('already at final state');
    expect(terminalFailure.attempted_transition).toBe('DONE -> [terminal]');
  });

  test('Task validation failures are logged with proper categorization', async () => {
    const currentSessionId = await createNewSession(client);
    await completeWorkflowToDelegation(client, currentSessionId);

    // Start a task but reference non-existent task in transition
    const taskResult = await client.callTool('start_task', {
      session_id: currentSessionId,
      task_id: 'real-task'
    });
    const realTaskId = JSON.parse(taskResult.content[0].text).task_id;

    await client.callTool('finish_task', {
      session_id: currentSessionId,
      task_id: realTaskId,
      status: 'COMPLETED'
    });

    // Try transition with non-existent task_id
    await expect(client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        task_ids: ['non-existent-task']
      }
    })).rejects.toThrow(/does not exist in session/);

    // Add a small delay to ensure file operations complete
    await new Promise(resolve => setTimeout(resolve, 200));

    // Clear cache and reload session to get latest state from disk
    sessionManager.clearCache();
    const sessionData = await sessionManager.loadSession(currentSessionId);

    const taskFailure = sessionData.transition_failures.find(f => f.type === 'invalid_reference');
    expect(taskFailure).toBeDefined();
    expect(taskFailure.details).toContain('does not exist in session');
    expect(taskFailure.attempted_transition).toBe('DELEGATION -> REVIEW_IMPLEMENTATION');
  });

  test('Session logging methods work correctly', async () => {
    const currentSessionId = await createNewSession(client);

    // Add a small delay to ensure session is fully created
    await new Promise(resolve => setTimeout(resolve, 100));

    // Test validation failure logging
    await sessionManager.logValidationFailure(
      currentSessionId, 
      'state_mismatch',
      'Message header state: PLAN, Current session state: ANALYSIS',
      'ANALYSIS',
      'PLAN'
    );

    // Test transition failure logging
    await sessionManager.logTransitionFailure(
      currentSessionId,
      'missing_evidence',
      'Missing required evidence field: plan_summary',
      'ANALYSIS -> PLAN'
    );

    // Add a small delay to ensure file operations complete
    await new Promise(resolve => setTimeout(resolve, 200));

    // Clear cache and reload session to get latest state from disk
    sessionManager.clearCache();
    const sessionData = await sessionManager.loadSession(currentSessionId);

    expect(sessionData.validation_failures).toBeDefined();
    expect(sessionData.validation_failures.length).toBe(1);

    const validationFailure = sessionData.validation_failures[0];
    expect(validationFailure.type).toBe('state_mismatch');
    expect(validationFailure.details).toBe('Message header state: PLAN, Current session state: ANALYSIS');
    expect(validationFailure.expected_state).toBe('ANALYSIS');
    expect(validationFailure.attempted_state).toBe('PLAN');
    expect(validationFailure.timestamp).toBeDefined();

    expect(sessionData.transition_failures).toBeDefined();
    expect(sessionData.transition_failures.length).toBe(1);

    const transitionFailure = sessionData.transition_failures[0];
    expect(transitionFailure.type).toBe('missing_evidence');
    expect(transitionFailure.details).toBe('Missing required evidence field: plan_summary');
    expect(transitionFailure.attempted_transition).toBe('ANALYSIS -> PLAN');
    expect(transitionFailure.timestamp).toBeDefined();
  });

  test('Successful transitions do not add failure logs', async () => {
    const currentSessionId = await createNewSession(client);

    // Perform a successful transition
    await client.callTool('request_next_state', {
      session_id: currentSessionId,
      evidence: {
        clarifying_questions_text: 'What is the main objective of this task?',
        clarifying_answers_text: 'The main objective is to create comprehensive integration tests.'
      },
      notes: 'Moving from analysis to planning phase'
    });

    // Add a small delay to ensure file operations complete
    await new Promise(resolve => setTimeout(resolve, 100));

    // Clear cache and reload session to get latest state from disk
    sessionManager.clearCache();
    const sessionData = await sessionManager.loadSession(currentSessionId);

    // Verify no failures were logged for successful operation
    expect(sessionData.transition_failures).toBeDefined();
    expect(sessionData.transition_failures.length).toBe(0);
    expect(sessionData.validation_failures).toBeDefined();
    expect(sessionData.validation_failures.length).toBe(0);

    // Verify the transition was successful
    expect(sessionData.current_state).toBe('PLAN');
    expect(sessionData.state_history.length).toBe(1);
  });
});
